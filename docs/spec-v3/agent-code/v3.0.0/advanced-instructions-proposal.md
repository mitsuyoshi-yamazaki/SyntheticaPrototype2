# 万能複製エージェント実現のための追加命令提案

## 概要

現在のコンパイル結果分析により、万能複製のような複雑な機能を実現するために以下の命令追加が望まれます。

## 1. ビットシフト命令（実装済み）

- **SHL (0xC2)** - 論理左シフト
- **SHR (0xC3)** - 論理右シフト  
- **SAR (0xC4)** - 算術右シフト

これにより、16bit値の組み立て（high << 8 | low）が可能になりました。

## 2. メモリブロック転送命令（提案）

### MEMCPY命令
```
オペコード: 0xC5
フォーマット: 5バイト命令
動作: メモリブロックの高速転送
パラメータ:
  - 第2,3バイト: 転送元アドレス（Aレジスタ相対）
  - 第4,5バイト: 転送バイト数
使用例:
  MEMCPY
  0x00 0x00   ; 転送元オフセット（Aレジスタ + 0）
  0x64 0x00   ; 100バイト転送
```

効果：
- プログラム転送の大幅な高速化
- エネルギー効率の改善
- コードサイズの削減

## 3. 動的ユニット操作命令（提案）

### UNIT_MEM_WRITE_DYN命令
```
オペコード: 0x9B
フォーマット: 4バイト命令
動作: レジスタで指定したアドレスへのユニットメモリ書き込み
パラメータ:
  - 第2バイト: ユニット指定（既存と同じ）
  - 第3バイト: アドレス指定レジスタ（0=A, 1=B, 2=C, 3=D）
  - 第4バイト: 未使用
使用例:
  ; Cレジスタにアドレスが入っている場合
  UNIT_MEM_WRITE_DYN
  0xC1        ; COMPUTER[1]
  0x02        ; Cレジスタのアドレスへ
  0x00        ; 未使用
```

効果：
- ループ内での動的アドレス書き込みが可能
- プログラム転送の簡略化

## 4. スタック操作命令（提案）

### PUSH/POP命令
```
PUSH_A (0x1E): Aレジスタをスタックにプッシュ
PUSH_B (0x1F): Bレジスタをスタックにプッシュ
POP_A  (0x2E): スタックからAレジスタにポップ
POP_B  (0x2F): スタックからBレジスタにポップ
```

効果：
- 関数呼び出しの実装が容易に
- レジスタの一時保存が簡単に
- より構造化されたプログラミングが可能

## 5. 条件付き実行命令（提案）

### CMOV命令（条件付き移動）
```
オペコード: 0xC6
フォーマット: 5バイト命令
動作: 条件が真の場合のみレジスタ移動
パラメータ:
  - 第2バイト: 条件（0=Z, 1=NZ, 2=C, 3=NC）
  - 第3バイト: ソースレジスタ
  - 第4バイト: 宛先レジスタ
  - 第5バイト: 未使用
```

効果：
- 分岐を減らしてパイプライン効率向上
- 条件処理の簡略化

## 6. 複合演算命令（提案）

### LEA命令（実効アドレス計算）
```
オペコード: 0xC7
フォーマット: 5バイト命令
動作: A = B + C * scale + offset
パラメータ:
  - 第2バイト: scale（1, 2, 4, 8）
  - 第3,4バイト: offset（16bit）
  - 第5バイト: 未使用
```

効果：
- 配列アクセスの高速化
- アドレス計算の簡略化

## 実装優先度

1. **高優先度**：
   - メモリブロック転送（MEMCPY）
   - 動的ユニット操作（UNIT_MEM_WRITE_DYN）

2. **中優先度**：
   - スタック操作（PUSH/POP）
   - 条件付き実行（CMOV）

3. **低優先度**：
   - 複合演算（LEA）

## まとめ

これらの命令追加により、以下が実現可能になります：

1. **効率的なプログラム転送** - MEMCPYによる高速転送
2. **動的メモリアクセス** - レジスタ指定によるユニット操作
3. **構造化プログラミング** - スタック操作による関数呼び出し
4. **最適化されたコード** - 条件付き実行と複合演算

特に最初の2つは、現在の万能複製実装の主要な課題を直接解決するため、優先的な実装が推奨されます。