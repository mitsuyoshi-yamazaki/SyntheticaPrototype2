## 概要

Synthetica Scriptは、COMPUTERが実行するプログラムを記述するプログラミング言語の総称である。
COMPUTERが実行するのはCOMPUTERのメモリに格納されたバイト列を命令セットとして解釈したもので、本ファイルではこの命令セットと、命令セットを人間が記述するためのアセンブリ言語の仕様を策定する。
今後のバージョンでは、アセンブリ言語をラップして構造化プログラミングの仕組みを導入したC言語コンパイラと、GUIベースプログラミングを追加する予定である。どちらもアセンブリ言語を経由して命令セットへ変換される。

## アーキテクチャ仕様

COMPUTERのアーキテクチャ仕様について
COMPUTERは以下の機能を持つ

- プログラムカウンタ
  - プログラムカウンタは8bitの変数である
    - これによりメモリの最大容量が定まる（2^8 = 256）
    - メモリ容量の最大値は256に固定される
  - 次に実行する命令のメモリ番地を示す
  - プログラムカウンタを操作する命令以外では、命令を実行したらプログラムカウンタを1進める
    - メモリの最後尾にある命令を実行した後は、プログラムカウンタはメモリの先頭を指す
- ワーキングレジスタ
  - A, B, C, Dの4本（各8bit）
- フラグ
  - キャリフラグ
  - ゼロフラグ
- メモリ領域
  - 各領域は8bit（1バイト）
  - メモリ容量の最大値は 2^8 = 256バイト
- 外部バス
  - 回路的に接続しているユニットへアクセスするためのもの
  - アクセス制御：複数COMPUTERが同じユニットにアクセスする場合、そのtickで最後に更新された状態をとる
- 動作周波数
  - COMPUTERの動作周波数は分数を取りうる（例：1命令/3tick）
  - 分数周波数の処理：各tickでCOMPUTERユニットがそのtickで何回命令を実行できるかを管理
  - 例：1/3周波数のCOMPUTERは、3tickのうち2tickは命令を実行しない（エネルギー消費もない）
- 備考
  - 割り込み機能は持たない
    - ソフトウェアの自由度や創発性に対して大きな利点があることがわかれば将来追加する
  - セキュリティ・安全性：意図しない動作やメモリ内容の破損は進化の原動力となるため、積極的な対策は行わない
  - 無限ループ：無限ループに陥ったCOMPUTERは単にそのエージェントに不利に働くのみで、アプリケーションへの追加負荷はないため、特に対応はしない

一般的に利用されているCPUと異なり、COMPUTERにはプログラムとデータの区別がない。
プログラムとデータを分離したプログラミングをしたい場合は、プログラム的にデータ領域の実行を禁止する。

## 設計要件と方針

### 設計要件

#### 大元の要件

- 人間がプログラミング可能（創発性の低い状態で設計ができること）かつ、
- シミュレーションが動作し始めたら創発性をもつこと
- （副次的な要件）進化の仕組みはシステムとしては提供しない（エージェントに進化の機能を持たせたいとしたら、人間がその"進化"をプログラミングする、もしくは偶然により自然発生的に進化が始まるのを待つ必要がある）：これは、進化の仕組みをシステムで提供することで、進化の手法にバイアスがかかることを防止するためである

#### 具体的な要件

- メモリ上の値を確認すれば、（他ユニットの挙動はさておき）COMPUTERの動作が一意に決定できること
- 未定義オペコードは安全に処理され、プログラムの実行が継続されること

### 設計方針

#### 1. 可変長命令方式

- 命令長を固定せず、命令の最初のバイトで命令長を決定
- 1バイト命令（頻出・基本命令）、2バイト命令（オペランド付き）、3バイト命令（拡張命令）

#### 2. テンプレートマッチング方式

- 特定のメモリアドレスを直接指定せず、パターンでアドレスを探索
- Tierraの設計思想を参考

#### 3. 単一値オペコード

- 各命令は固有の単一オペコード値を持つ
- 未定義オペコードの検出が可能で、より明確なエラー処理

#### 4. 相対アドレッシング中心

- 絶対アドレスではなく、現在位置からの相対位置で指定
- コードの位置独立性を確保

#### 5. 最小限の命令セット

- チューリング完全性を保ちつつ最小限の命令数

## アセンブラ言語仕様

### メモリモデル

- メモリは8bitアドレス空間（256バイト）
- 循環バッファ型（アドレス255の次は0）
- メモリの各領域は8bit（1バイト）
- アドレッシングモード：
  - 相対アドレス：PC相対またはレジスタ相対（2バイト命令、低コスト）
  - 絶対アドレス：直接アドレス指定（3バイト命令、高コスト）
  - テンプレート：パターンマッチング（可変長、位置独立）

### レジスタ構成

- PC（プログラムカウンタ）: 8bit
- ワーキングレジスタ: A, B, C, D の4本（各8bit）
- フラグレジスタ:
  - Z（ゼロフラグ）: 最後の演算結果が0の時にセット
  - C（キャリーフラグ）: 加算時の桁上がり、減算時の桁下がりでセット

### 命令フォーマット

#### 命令長の判定

第1バイトの値により命令長が決定される：

- 0x00-0x3F: 1バイト命令
- 0x40-0x7F: 2バイト命令
- 0x80-0xFF: 3バイト命令

### 命令一覧

#### 1バイト命令（0x00-0x3F）

##### データ移動命令

- **0x00: NOP0** - テンプレート用NOP（値0）
- **0x01: NOP1** - テンプレート用NOP（値1）
- **0x02: XCHG** - レジスタAとBを交換
- **0x03: MOV_AB** - レジスタAをBにコピー
- **0x04: MOV_AD** - レジスタAをDにコピー
- **0x05: MOV_BA** - レジスタBをAにコピー
- **0x06: MOV_DA** - レジスタDをAにコピー
- **0x07: MOV_BC** - レジスタBをCにコピー
- **0x08: MOV_CB** - レジスタCをBにコピー
- **0x09: MOV_AC** - レジスタAをCにコピー
- **0x0A: MOV_CA** - レジスタCをAにコピー
- **0x0B: MOV_CD** - レジスタCをDにコピー
- **0x0C: MOV_DC** - レジスタDをCにコピー
- **0x0D-0x0F: 未定義**

##### 算術演算命令

- **0x10: INC_A** - レジスタAをインクリメント
- **0x11: INC_B** - レジスタBをインクリメント
- **0x12: INC_C** - レジスタCをインクリメント
- **0x13: INC_D** - レジスタDをインクリメント
- **0x14: DEC_A** - レジスタAをデクリメント
- **0x15: DEC_B** - レジスタBをデクリメント
- **0x16: DEC_C** - レジスタCをデクリメント
- **0x17: DEC_D** - レジスタDをデクリメント
- **0x18: ADD_AB** - A = A + B（キャリーフラグ更新）
- **0x19: SUB_AB** - A = A - B（キャリーフラグ更新）
- **0x1A: XOR_AB** - A = A XOR B（ゼロフラグ更新）
- **0x1B: AND_AB** - A = A AND B（ゼロフラグ更新）
- **0x1C: OR_AB** - A = A OR B（ゼロフラグ更新）
- **0x1D: NOT_A** - A = NOT A（ゼロフラグ更新）
- **0x1E: CMP_AB** - A - B（フラグのみ更新、Aは変更なし）
- **0x1F-0x3F: 未定義**

#### 2バイト命令（0x40-0x7F）

第2バイトはオペランドまたは相対オフセット

##### メモリアクセス命令（相対アドレス）

- **0x40: LOAD_A** - A = Memory[PC + 符号付きオフセット]
- **0x41: STORE_A** - Memory[PC + 符号付きオフセット] = A
- **0x42: LOAD_IND** - A = Memory[B + 符号付きオフセット]
- **0x43: STORE_IND** - Memory[B + 符号付きオフセット] = A
- **0x44-0x4F: 未定義**

##### レジスタベースメモリアクセス命令

- **0x50: LOAD_REG** - A = Memory[レジスタ値]
  - 第2バイト: レジスタ指定（0=A, 1=B, 2=C, 3=D）
- **0x51: STORE_REG** - Memory[レジスタ値] = A
  - 第2バイト: レジスタ指定（0=A, 1=B, 2=C, 3=D）
- **0x52: LOAD_IND_REG** - A = Memory[Memory[第2バイト]]（間接）
- **0x53: STORE_IND_REG** - Memory[Memory[第2バイト]] = A（間接）
- **0x54-0x5F: 未定義**

##### 制御命令

- **0x60: JMP** - PC = PC + 符号付きオフセット
- **0x61: JZ** - ゼロフラグがセットならジャンプ
- **0x62: JNZ** - ゼロフラグがクリアならジャンプ
- **0x63: JC** - キャリーフラグがセットならジャンプ（unsigned <）
- **0x64: JNC** - キャリーフラグがクリアならジャンプ（unsigned >=）
- **0x65: CALL** - Cレジスタに戻り先を保存してジャンプ
- **0x66: JG** - 符号付き大なり（A > B after CMP_AB）
- **0x67: JLE** - 符号付き以下（A <= B after CMP_AB）
- **0x68: JGE** - 符号付き以上（A >= B after CMP_AB）
- **0x69: JL** - 符号付き小なり（A < B after CMP_AB）
- **0x6A-0x7F: 未定義**

#### 3バイト命令（0x80-0xFF）

第2,3バイトで拡張オペランドを指定

##### パターンマッチング命令

- **0x80: SEARCH_F** - 前方検索（可変長テンプレート）
  - 次バイト以降のNOP0/NOP1列をテンプレートとして使用
  - テンプレート終端: 最初の非NOP命令まで
  - 補完パターンをメモリ内で検索
  - 結果: 見つかった位置をBレジスタに格納、見つからなければB=0xFF
- **0x81: SEARCH_B** - 後方検索（SEARCH_Fと同様）
- **0x82: SEARCH_F_MAX** - 前方検索（最大距離指定）
  - 第2バイト: 最大検索距離
  - 第3バイト以降: テンプレート（可変長）
- **0x83: SEARCH_B_MAX** - 後方検索（SEARCH_F_MAXと同様）
- **0x84-0x8F: 未定義**

##### ユニット操作命令（メモリマップドI/O）

- **0x90: UNIT_MEM_READ** - 外部ユニットメモリ読み取り
  - 第2バイト: ユニット種別とインデックス（上位4bit:種別、下位4bit:インデックス）
  - 第3バイト: ユニット内メモリアドレス
  - 結果: Aレジスタに格納
- **0x91: UNIT_MEM_WRITE** - 外部ユニットメモリ書き込み
  - 第2バイト: ユニット種別とインデックス（上位4bit:種別、下位4bit:インデックス）
  - 第3バイト: ユニット内メモリアドレス
  - Aレジスタの値を書き込み
- **0x92: UNIT_MEM_READ_REG** - レジスタ指定で外部ユニットメモリ読み取り
  - 第2バイト: 上位4bit=ユニット指定レジスタ（0-3）、下位4bit=アドレスレジスタ（0-3）
  - 第3バイト: 未使用（0x00）
  - 結果: Aレジスタに格納
- **0x93: UNIT_MEM_WRITE_REG** - レジスタ指定で外部ユニットメモリ書き込み
  - 第2バイト: 上位4bit=ユニット指定レジスタ（0-3）、下位4bit=アドレスレジスタ（0-3）
  - 第3バイト: 未使用（0x00）
  - Aレジスタの値を書き込み
- **0x94-0x9F: 未定義**

##### メモリアクセス命令（絶対アドレス）

- **0xA0: LOAD_ABS** - A = Memory[第2バイト] （自身のメモリの絶対アドレス）
- **0xA1: STORE_ABS** - Memory[第2バイト] = A （自身のメモリの絶対アドレス）
- **0xA2-0xAF: 未定義**

##### 間接ジャンプ命令

- **0xB0: JMP_IND** - PC = レジスタの値（第2バイトでレジスタ指定: 0=A, 1=B, 2=C, 3=D）
- **0xB1: JMP_ABS** - PC = 第2バイト （絶対アドレスへジャンプ）
- **0xB2: RET** - PC = C（CALLからの復帰専用、第2,3バイトは無視）
- **0xB3-0xBF: 未定義**

##### 拡張演算命令

- **0xC0: MUL_AB** - A = (A \* B) & 0xFF
- **0xC1: DIV_AB** - A = A / B, B = A % B （除算とモジュロ）
- **0xC2-0xDF: 未定義**
- **0xE0: LOAD_IMM** - A = 第2バイト
- **0xE1-0xEF: 未定義**
- **0xF0: NOP3** - 3バイトNOP（パディング用）
- **0xF1-0xFF: 未定義**

### テンプレートマッチング仕様

#### 基本概念

- テンプレートはNOP0（値0）とNOP1（値1）の列で構成
- 補完パターンマッチング: 検索時は元パターンの0と1を反転したパターンを探す
- 可変長テンプレート: 最初の非NOP命令までがテンプレート
- 部分マッチング: 長いテンプレートに短いテンプレートの補完がマッチ可能

#### 補完パターンの例

```
定義側:  NOP1 NOP1 NOP0 NOP0  ; パターン: 1100
検索側:  NOP0 NOP0 NOP1 NOP1  ; 補完: 0011を探す
```

#### エネルギーコスト

- 基本実行コスト: 0.2E
- テンプレート長コスト: template_length × 0.05E
- 検索距離コスト: actual_distance × 0.01E
- 失敗時: 基本コスト + 最大検索距離 × 0.01E

#### 使用例

```
; ラベル定義（ジャンプ先）
LOOP_START:
  NOP1 NOP1 NOP0 NOP1    ; テンプレート: 1101
  MOV_AB                 ; 実際のコード開始
  ; ... ループ本体 ...

; ラベル参照（ジャンプ元）
  SEARCH_B               ; 後方検索
  NOP0 NOP0 NOP1 NOP0    ; 補完パターン: 0010を探す
  JMP_IND                ; Bレジスタ（検索結果）にジャンプ
  0x01                   ; レジスタB指定
  0x00                   ; 未使用
```

#### 自己参照の防止

補完パターンを使用するため、定義側のテンプレートが自分自身にマッチすることはない。これにより、最も近い「他の」ラベルを確実に見つけることができる。

#### 部分マッチングの動作

```
長いテンプレート:  NOP1 NOP1 NOP0 NOP0 NOP1  ; 11001
短い補完パターン:  NOP0 NOP0 NOP1              ; 001
→ 最初の3ビットの補完としてマッチ
```

### 外部ユニット操作仕様（メモリマップドI/O）

#### ユニット種別コード（上位4bit）

- 0x0: HULL
- 0x4: ASSEMBLER  
- 0x8: DISASSEMBLER
- 0xC: COMPUTER
- その他: 予約

#### ユニットメモリマップ

各ユニットは固有のメモリ領域を持ち、以下のような構成：

##### HULL（16バイト）
```
0x00: 現在の格納量
0x01: 最大容量
0x02: エネルギー回収ON/OFF（0=OFF, 1=ON）
0x03: マージ対象HULL ID
0x04-0x05: エネルギー保有量（16bit、下位・上位）
0x06: 分離対象ユニット種別
0x07: 分離対象ユニットインデックス
0x08: 分離実行フラグ（1を書き込むと実行）
0x09-0x0F: 予約
```

##### ASSEMBLER（32バイト）
```
0x00-0x01: 状態（稼働中/待機中、進捗率など）
0x02-0x03: 生産中ユニット情報
0x10: 生産ユニット種別
0x11-0x1E: 生産パラメータ（種別ごとに異なる）
0x1F: 生産開始フラグ（1を書き込むと開始）
```

##### DISASSEMBLER（16バイト）
```
0x00-0x01: 状態
0x02: ターゲット指定方法（0=隣接任意、1=ユニットID指定）
0x03: ターゲットユニットID（指定時のみ）
0x04: 投入エネルギー量
0x05: 分解実行フラグ
0x06-0x0F: 予約
```

##### COMPUTER（特殊）
```
0x00-0xFF: プログラムメモリ（サイズは生成時指定）
末尾1バイト: 外部書き換え許可フラグ（0=拒否、1=許可）
```

### アドレッシングモードの使い分け

#### 相対アドレス（推奨：低コスト）

```
; ローカル変数・作業領域
STORE_A     ; 近くのメモリに保存
0x05        ; PC+5の位置
; ... 処理 ...
LOAD_A      ; 同じ相対位置から読み出し
0x05
```

#### 絶対アドレス（グローバル変数用）

```
; 共有メモリ領域（アドレス200-220を共有エリアとする）
STORE_ABS   ; 絶対アドレス200に保存
0xC8        ; 200番地
0x00        ; 第3バイト（未使用）

; 別の場所から読み出し
LOAD_ABS    ; 絶対アドレス200から読み出し
0xC8
0x00
```

#### テンプレート（位置独立コード）

```
; 重要なデータの位置をマーク
IMPORTANT_DATA:
  NOP1 NOP1 NOP0 NOP0    ; マーカー: 1100
  0x00                   ; データ本体

; 後でテンプレートで検索
SEARCH_F                 ; 前方検索
NOP0 NOP0 NOP1 NOP1    ; 補完: 0011を探す
LOAD_IND                ; 見つかった位置+1から読み出し
0x01
```

### エネルギー消費

各命令の実行には以下のエネルギーを消費：

- 1バイト命令: 0.1E
- 2バイト命令: 0.2E
  - レジスタベース命令（LOAD_REG, STORE_REG）: 0.25E
  - 間接アドレス命令（LOAD_IND_REG, STORE_IND_REG）: 0.3E
- 3バイト命令: 0.3E
  - 絶対アドレス命令（LOAD_ABS, STORE_ABS, JMP_ABS）: 0.5E（高コスト）
  - レジスタベースユニット操作: 0.35E + 1E（ユニット操作）
- テンプレートマッチング:
  - 基本コスト: 0.2E
  - テンプレート長: length × 0.05E
  - 検索距離: distance × 0.01E
- ユニット操作: 1E 追加

### サブルーチン呼び出しの例

```
; メインプログラム
0x00: LOAD_IMM    ; A = 5
0x01: 0x05
0x02: CALL        ; サブルーチンを呼び出し
0x03: 0x10        ; +16バイト先（0x12）へジャンプ
0x04: NOP         ; ここに戻ってくる
; ... メインプログラムの続き

; サブルーチン（0x12から）
0x12: INC_A       ; Aをインクリメント
0x13: RET         ; Cレジスタの値（0x04）に戻る
0x14: 0x00        ; 第2バイト（無視される）
0x15: 0x00        ; 第3バイト（無視される）
```

### 複数ユニットアクセスの例

```
; 3つのASSEMBLERから空いているものを探す
  LOAD_IMM    ; D = 0（最初のASSEMBLER）
  0x00
  MOV_AD

FIND_FREE:
  ; Dレジスタの値を使ってユニット指定バイトを作成
  MOV_DA      ; D→A
  ADD_AB      ; A = A + 0x40（Bに0x40を事前設定必要）
  MOV_AB      ; 一時保存
  
  UNIT_MEM_READ ; ASSEMBLER[D]の状態確認
  ; 第2バイトはBレジスタから（0x40 + D）
  0x00        ; アドレス0x00（状態）

  JZ          ; 空いていれば使用
  0x08        ; USE_ITへ

  INC_D       ; 次のASSEMBLERへ
  LOAD_IMM    ; A = 3（ASSEMBLERの総数）
  0x03
  MOV_DA      ; D→A
  XOR_AB      ; A == 3なら0（全て確認済み）
  JZ          ; 全て使用中
  0x10        ; エラー処理へ

  JMP         ; 次を確認
  -0x10       ; FIND_FREEへ戻る

USE_IT:
  ; D番目のASSEMBLERを使用
  ; パラメータ設定と開始は上記の例と同様
```

### 子COMPUTERへのプログラム転送例（レジスタベース版）

```
; 新しく生成されたCOMPUTERにプログラムを転送
; 前提：新COMPUTERのインデックスがDレジスタに格納済み

; まず待機ループを書き込む
  LOAD_IMM    ; A = JMP命令
  0x60
  MOV_AD      ; D = COMPUTER[新index]（例：0xC1）
  MOV_BC      ; C = 0（アドレス）
  UNIT_MEM_WRITE_REG
  0x3C        ; Dレジスタ（ユニット）、Cレジスタ（アドレス）
  0x00

  LOAD_IMM    ; A = -2（自分自身へジャンプ）
  0xFE
  INC_C       ; C = 1
  UNIT_MEM_WRITE_REG
  0x3C        ; D、Cレジスタ使用
  0x00

; メインプログラムを書き込む（アドレス2から）
  LOAD_IMM    ; B = 2（ソースアドレス）
  0x02
  MOV_AB
  LOAD_IMM    ; C = 2（宛先アドレス）
  0x02
  MOV_AC

TRANSFER_LOOP:
  ; 自分のメモリから読み出し
  LOAD_REG    ; A = Memory[B]
  0x01        ; Bレジスタ
  
  ; 子COMPUTERに書き込み（D=ユニット、C=アドレス）
  UNIT_MEM_WRITE_REG
  0x3C        ; Dレジスタ、Cレジスタ
  0x00
  
  INC_B       ; ソースポインタ++
  INC_C       ; 宛先アドレス++
  
  ; 転送完了判定（例：100バイト転送）
  MOV_CB      ; B→C を一時保存
  LOAD_IMM    ; A = 100
  0x64
  CMP_AB      ; B - 100
  MOV_BC      ; C→B を復元
  JLE         ; B <= 100ならループ継続
  -0x10       ; TRANSFER_LOOPへ

; 最後に待機ループを解除
  LOAD_IMM    ; A = NOP
  0x00
  MOV_BC      ; C = 0
  UNIT_MEM_WRITE_REG
  0x3C
  0x00

; 書き換え許可を拒否に変更
  LOAD_IMM    ; A = 0（拒否）
  0x00
  LOAD_IMM    ; C = 0xFF
  0xFF
  MOV_AC
  UNIT_MEM_WRITE_REG
  0x3C
  0x00
```

### 配列処理の例（新命令使用）

```
; 配列の合計を計算（配列は0x80から開始、長さ16）
  LOAD_IMM    ; B = 0x80（配列開始）
  0x80
  MOV_AB
  LOAD_IMM    ; C = 0（合計）
  0x00
  MOV_AC
  LOAD_IMM    ; D = 16（カウンタ）
  0x10
  MOV_AD

ARRAY_LOOP:
  LOAD_REG    ; A = Memory[B]（配列要素）
  0x01        ; Bレジスタ
  
  ADD_AB      ; A = A + B（※Bは一時的に合計として使用）
  MOV_CB      ; 合計を保存
  INC_B       ; 配列ポインタ++
  DEC_D       ; カウンタ--
  
  MOV_DA      ; D→A
  JNZ         ; カウンタ != 0ならループ
  -0x08       ; ARRAY_LOOPへ
  
  ; 結果はCレジスタに格納
```

### 間接アドレッシングの例

```
; ポインタ配列を使った処理
; メモリ0xF0にデータのアドレスが格納されている

  LOAD_IND_REG ; A = Memory[Memory[0xF0]]
  0xF0         ; 0xF0の内容が指すアドレスから読み込み
  
  ; ポインタ経由で書き込み
  LOAD_IMM     ; A = 書き込む値
  0x42
  STORE_IND_REG ; Memory[Memory[0xF1]] = A
  0xF1         ; 0xF1の内容が指すアドレスへ書き込み
```

### 自己複製プログラムの例

```
; テンプレートマッチングを使用した自己複製プログラム
; 前提: HULLに固定されたASSEMBLERがある

; プログラム開始位置マーカー
START:
  NOP1 NOP0 NOP1 NOP0    ; テンプレート: 1010
  LOAD_IMM               ; A = プログラムサイズ
  0x40                   ; 64バイト

; 複数ASSEMBLERがある場合、最初のものを選択
  LOAD_IMM               ; D = 0（最初のASSEMBLER）
  0x00
  MOV_AD                 ; A→D

; ASSEMBLERにCOMPUTER生成を指示
  ; まず生産パラメータを設定
  LOAD_IMM               ; A = COMPUTER種別コード
  0xC0
  UNIT_MEM_WRITE         ; ASSEMBLER[0]のメモリに書き込み
  0x40                   ; 種別4、インデックス0
  0x10                   ; アドレス0x10（生産ユニット種別）
  
  LOAD_IMM               ; A = 動作周波数
  0x01                   ; 1命令/tick
  UNIT_MEM_WRITE
  0x40
  0x11                   ; アドレス0x11（パラメータ1）
  
  LOAD_IMM               ; A = メモリサイズ
  0x80                   ; 128バイト
  UNIT_MEM_WRITE
  0x40
  0x12                   ; アドレス0x12（パラメータ2）
  
  ; 生産開始
  LOAD_IMM               ; A = 1（開始フラグ）
  0x01
  UNIT_MEM_WRITE
  0x40
  0x1F                   ; アドレス0x1F（生産開始フラグ）

; 生成完了待機ループ
WAIT_LOOP:
  NOP0 NOP1 NOP0 NOP1    ; テンプレート: 0101
  UNIT_MEM_READ          ; ASSEMBLER[0]の状態確認
  0x40                   ; 種別4、インデックス0
  0x00                   ; アドレス0x00（状態）
  ; 状態の下位bitが0なら待機中
  JZ                     ; 完了なら次へ
  0x08                   ; +8バイトジャンプ（COPY_STARTへ）

  ; ループ継続（WAIT_LOOPへ戻る）
  SEARCH_B               ; 後方検索
  NOP1 NOP0 NOP1 NOP0    ; 補完パターン: 1010を探す
  JMP_IND                ; 見つかった位置へジャンプ
  0x01                   ; Bレジスタ指定
  0x00                   ; 未使用

; コピー処理開始
COPY_START:
  NOP1 NOP1 NOP0 NOP0    ; テンプレート: 1100
  LOAD_IMM               ; B = 0（コピー元アドレス）
  0x00
  LOAD_IMM               ; C = プログラムサイズ
  0x40

; メモリコピーループ
COPY_LOOP:
  NOP0 NOP1 NOP1 NOP0    ; テンプレート: 0110
  LOAD_IND               ; A = Memory[B]
  0x00                   ; オフセット0
  UNIT_CMD               ; 新COMPUTERメモリ書き込み
  0xC0                   ; COMPUTER種別
  0x02                   ; メモリ書き込みコマンド
  INC_A                  ; B++（次のアドレス）
  MOV_AB                 ; A→B
  DEC_C                  ; カウンタ減算
  JNZ                    ; まだ残りがあれば
  0x08                   ; +8バイト先へ（次の検索命令をスキップ）

  ; ループ継続（COPY_LOOPへ戻る）
  SEARCH_B               ; 後方検索
  NOP1 NOP0 NOP0 NOP1    ; 補完パターン: 1001を探す
  JMP_IND                ; 見つかった位置へジャンプ
  0x01                   ; Bレジスタ指定
  0x00                   ; 未使用

; 新COMPUTERを分離
  UNIT_CMD               ; HULLへコマンド
  0x00                   ; HULL種別
  0x03                   ; 分離コマンド
```

### COMPUTERの生成について

- COMPUTERは唯一自律動作するユニットである。生成が完了した次のtickから動作を始めるが、生成直後はプログラムカウンタ、ワーキングレジスタ、フラグ、メモリの全ての値は0である
  - その状態（NOP命令のみがメモリに入っている）でCOMPUTERが動作しても何も行わない（メモリの最後までNOP命令を実行したら、またメモリの先頭へ戻って実行）
  - 生成したCOMPUTERに意味のある仕事を行わせたい場合、先頭にループを書き込んでおき、そのループを実行している間にメモリに内容を書き込み、最後にその先頭ループを削除（NOPで上書き）する、という手順でメモリの書き込みを行うことができる

### 外部ユニットとのメモリマップドI/O

#### 基本概念
- 全てのユニットは固有のメモリ領域を持つ
- 接続されたユニットのメモリは、UNIT_MEM_READ/UNIT_MEM_WRITE命令でアクセス
- 複数引数を要する操作は、引数を全て書き込んでから実行フラグを設定

#### アクセス方式
```
; ユニット指定（第2バイト）
; 上位4bit: ユニット種別（0x0=HULL, 0x4=ASSEMBLER, 0x8=DISASSEMBLER, 0xC=COMPUTER）
; 下位4bit: 同種ユニットのインデックス（0-15）

; 例：3番目のASSEMBLER（種別0x4、インデックス3）
0x43  ; = 0x40 | 0x03
```

#### 利点
- **アトミック性**: 全パラメータ設定後に実行
- **統一性**: 全ユニットが同じインターフェース
- **拡張性**: 新ユニット追加が容易

### メモリ書き込み機構（暫定案B採用）

- COMPUTERは「外部からのメモリ書き換え許可/拒否」プロパティを持つ
- 生成時は「許可」状態で生成される
- 親COMPUTERは生成した子COMPUTERのメモリに書き込み可能（UNIT_MEM_WRITE使用）
- 書き込み完了後、子COMPUTERの書き換え許可を「拒否」に変更することを推奨

### 命令実行とメモリ破損への耐性

#### 命令境界のずれへの対応

- 可変長命令により、命令境界のずれは最悪でも3バイト以内に正常化
- 未定義オペコードはNOP扱いとして実行を継続

#### メモリ内容変化への対応

- NOP0（0x00）とNOP1（0x01）により、テンプレート機能を維持
- ゼロクリアされた領域はNOP0として安全に実行可能
- 補完パターンマッチングにより、コードの位置が変わっても動作継続可能

#### 進化の可能性

- ビット反転により別の命令に変化する可能性
- パターンの変化により、ジャンプ先が変更
- 未定義領域の存在により、将来の命令拡張の余地を確保

## TODO項目

### 解決済み項目

- ✅ ワーキングレジスタ: A, B, C, Dの4本（各8bit）
- ✅ フラグ: ゼロフラグとキャリーフラグの2種類
- ✅ メモリ: 各8bitアドレス、最大256バイト
- ✅ 命令セット: 可変長命令（1-3バイト）、完全定義済み
- ✅ テンプレートマッチング: NOP0/NOP1による補完パターン方式
- ✅ エネルギー消費: 命令種別ごとに定義済み
- ✅ メモリ書き込み機構: 暫定案B採用（外部書き換え許可/拒否プロパティ）
- ✅ アドレッシングモード: 相対・絶対・テンプレート・レジスタベース・間接の5方式
- ✅ 複数ユニット識別: Dレジスタによるインデックス方式
- ✅ 動的メモリアクセス: レジスタベース・間接アドレッシング命令追加
- ✅ 比較演算: SUB_AB、CMP_AB、条件分岐命令（JC/JNC/JG/JLE）追加

### 未解決項目

#### 1. 外部ユニット連携

- TODO: ユニット種別コードの詳細定義（現在は例示のみ）
- TODO: HULLのdetach操作メモリマップ定義
- TODO: アクション予約タイミング（即座実行 or 次tick予約）

#### 2. メモリ書き込み機構の詳細

- TODO: 外部書き換え許可状態の切り替え方法
- TODO: 複数COMPUTERからの同時書き込み競合処理
- TODO: 部分書き込み時の一貫性保証

#### 3. パフォーマンス関連

- TODO: テンプレートマッチングの最大検索距離のデフォルト値
- TODO: 動作周波数の実用的な上限値（現在はコストで制限）

#### 4. 16bitアドレス空間への拡張

- TODO: プログラムカウンタの16bit化検討
- TODO: メモリアドレスの16bit化検討
- TODO: 既存命令との互換性維持方法
