## 概要

Synthetica Scriptは、COMPUTERが実行するプログラムを記述するプログラミング言語の総称である。
COMPUTERが実行するのはCOMPUTERのメモリに格納されたバイト列を命令セットとして解釈したもので、本ファイルではこの命令セットと、命令セットを人間が記述するためのアセンブリ言語の仕様を策定する。
今後のバージョンでは、アセンブリ言語をラップして構造化プログラミングの仕組みを導入したC言語コンパイラと、GUIベースプログラミングを追加する予定である。どちらもアセンブリ言語を経由して命令セットへ変換される。

## アーキテクチャ仕様

COMPUTERのアーキテクチャ仕様について
COMPUTERは以下の機能を持つ

- プログラムカウンタ
  - プログラムカウンタは8bitの変数である
    - これによりメモリの最大容量が定まる（2^8 = 256）
    - メモリ容量の最大値は256に固定される
  - 次に実行する命令のメモリ番地を示す
  - プログラムカウンタを操作する命令以外では、命令を実行したらプログラムカウンタを1進める
    - メモリの最後尾にある命令を実行した後は、プログラムカウンタはメモリの先頭を指す
- ワーキングレジスタ
  - A, B, C, Dの4本（各8bit）
- フラグ
  - キャリフラグ
  - ゼロフラグ
- メモリ領域
  - 各領域は8bit（1バイト）
  - メモリ容量の最大値は 2^8 = 256バイト
- 外部バス
  - 回路的に接続しているユニットへアクセスするためのもの
  - アクセス制御：複数COMPUTERが同じユニットにアクセスする場合、そのtickで最後に更新された状態をとる
- 動作周波数
  - COMPUTERの動作周波数は分数を取りうる（例：1命令/3tick）
  - 分数周波数の処理：各tickでCOMPUTERユニットがそのtickで何回命令を実行できるかを管理
  - 例：1/3周波数のCOMPUTERは、3tickのうち2tickは命令を実行しない（エネルギー消費もない）
- 備考
  - 割り込み機能は持たない
    - ソフトウェアの自由度や創発性に対して大きな利点があることがわかれば将来追加する
  - セキュリティ・安全性：意図しない動作やメモリ内容の破損は進化の原動力となるため、積極的な対策は行わない
  - 無限ループ：無限ループに陥ったCOMPUTERは単にそのエージェントに不利に働くのみで、アプリケーションへの追加負荷はないため、特に対応はしない

一般的に利用されているCPUと異なり、COMPUTERにはプログラムとデータの区別がない。
プログラムとデータを分離したプログラミングをしたい場合は、プログラム的にデータ領域の実行を禁止する。

## 設計要件と方針

### 設計要件

#### 大元の要件

- 人間がプログラミング可能（創発性の低い状態で設計ができること）かつ、
- シミュレーションが動作し始めたら創発性をもつこと
- （副次的な要件）進化の仕組みはシステムとしては提供しない（エージェントに進化の機能を持たせたいとしたら、人間がその"進化"をプログラミングする、もしくは偶然により自然発生的に進化が始まるのを待つ必要がある）：これは、進化の仕組みをシステムで提供することで、進化の手法にバイアスがかかることを防止するためである

#### 具体的な要件

- メモリ上の値を確認すれば、（他ユニットの挙動はさておき）COMPUTERの動作が一意に決定できること
- メモリ上の値、ワーキングレジスタの値、プログラムカウンタの値が欠損、破損、変更しても、実行されるSynthetica Scriptの命令として解釈できること

### 設計方針

#### 1. 可変長命令方式

- 命令長を固定せず、命令の最初のバイトで命令長を決定
- 1バイト命令（頻出・基本命令）、2バイト命令（オペランド付き）、3バイト命令（拡張命令）

#### 2. テンプレートマッチング方式

- 特定のメモリアドレスを直接指定せず、パターンでアドレスを探索
- Tierraの設計思想を参考

#### 3. 冗長エンコーディング

- 256種類のオペコードを少数の実命令にマッピング
- DNAのコドンのように、全ての値が有効な命令として解釈される

#### 4. 相対アドレッシング中心

- 絶対アドレスではなく、現在位置からの相対位置で指定
- コードの位置独立性を確保

#### 5. 最小限の命令セット

- チューリング完全性を保ちつつ最小限の命令数

## アセンブラ言語仕様

### メモリモデル

- メモリは8bitアドレス空間（256バイト）
- 循環バッファ型（アドレス255の次は0）
- メモリの各領域は8bit（1バイト）
- アドレッシングモード：
  - 相対アドレス：PC相対またはレジスタ相対（2バイト命令、低コスト）
  - 絶対アドレス：直接アドレス指定（3バイト命令、高コスト）
  - テンプレート：パターンマッチング（可変長、位置独立）

### レジスタ構成

- PC（プログラムカウンタ）: 8bit
- ワーキングレジスタ: A, B, C, D の4本（各8bit）
- フラグレジスタ:
  - Z（ゼロフラグ）: 最後の演算結果が0の時にセット
  - C（キャリーフラグ）: 加算時の桁上がり、減算時の桁下がりでセット

### 命令フォーマット

#### 命令長の判定

第1バイトの値により命令長が決定される：

- 0x00-0x3F: 1バイト命令
- 0x40-0x7F: 2バイト命令
- 0x80-0xFF: 3バイト命令

### 命令一覧

#### 1バイト命令（0x00-0x3F）

##### データ移動命令

- **0x00-0x03: NOP0** - テンプレート用NOP（値0）
- **0x04-0x07: NOP1** - テンプレート用NOP（値1）
- **0x08-0x0F: XCHG** - レジスタAとBを交換
- **0x10-0x13: MOV_AB** - レジスタAをBにコピー
- **0x14-0x17: MOV_AD** - レジスタAをDにコピー
- **0x18-0x1B: MOV_BA** - レジスタBをAにコピー
- **0x1C-0x1F: MOV_DA** - レジスタDをAにコピー

##### 算術演算命令

- **0x20-0x23: INC_A** - レジスタAをインクリメント
- **0x24-0x27: INC_D** - レジスタDをインクリメント（ユニットインデックス用）
- **0x28-0x2B: DEC_A** - レジスタAをデクリメント
- **0x2C-0x2F: DEC_D** - レジスタDをデクリメント（ユニットインデックス用）
- **0x30-0x33: ADD_AB** - A = A + B（キャリーフラグ更新）
- **0x34-0x37: SUB_AB** - A = A - B（キャリーフラグ更新）
- **0x38-0x3B: XOR_AB** - A = A XOR B（ゼロフラグ更新）
- **0x3C-0x3F: CMP_AB** - A - B（フラグのみ更新、Aは変更なし）

#### 2バイト命令（0x40-0x7F）

第2バイトはオペランドまたは相対オフセット

##### メモリアクセス命令（相対アドレス）

- **0x40-0x47: LOAD_A** - A = Memory[PC + 符号付きオフセット]
- **0x48-0x4F: STORE_A** - Memory[PC + 符号付きオフセット] = A
- **0x50-0x57: LOAD_IND** - A = Memory[B + 符号付きオフセット]
- **0x58-0x5F: STORE_IND** - Memory[B + 符号付きオフセット] = A

##### 制御命令

- **0x60-0x63: JMP** - PC = PC + 符号付きオフセット
- **0x64-0x67: JZ** - ゼロフラグがセットならジャンプ
- **0x68-0x6B: JNZ** - ゼロフラグがクリアならジャンプ
- **0x6C-0x6F: JC** - キャリーフラグがセットならジャンプ（unsigned <）
- **0x70-0x73: JNC** - キャリーフラグがクリアならジャンプ（unsigned >=）
- **0x74-0x77: CALL** - Cレジスタに戻り先を保存してジャンプ
- **0x78-0x7B: JG** - 符号付き大なり（A > B after CMP_AB）
- **0x7C-0x7F: JLE** - 符号付き以下（A <= B after CMP_AB）

#### 3バイト命令（0x80-0xFF）

第2,3バイトで拡張オペランドを指定

##### パターンマッチング命令

- **0x80-0x87: SEARCH_F** - 前方検索（可変長テンプレート）
  - 次バイト以降のNOP0/NOP1列をテンプレートとして使用
  - テンプレート終端: 最初の非NOP命令まで
  - 補完パターンをメモリ内で検索
  - 結果: 見つかった位置をBレジスタに格納、見つからなければB=0xFF
- **0x88-0x8F: SEARCH_B** - 後方検索（SEARCH_Fと同様）
- **0x90-0x97: SEARCH_F_MAX** - 前方検索（最大距離指定）
  - 第2バイト: 最大検索距離
  - 第3バイト以降: テンプレート（可変長）
- **0x98-0x9F: SEARCH_B_MAX** - 後方検索（SEARCH_F_MAXと同様）

##### ユニット操作命令（メモリマップドI/O）

- **0xA0-0xA7: UNIT_MEM_READ** - 外部ユニットメモリ読み取り
  - 第2バイト: ユニット種別とインデックス（上位4bit:種別、下位4bit:インデックス）
  - 第3バイト: ユニット内メモリアドレス
  - 結果: Aレジスタに格納
- **0xA8-0xAF: UNIT_MEM_WRITE** - 外部ユニットメモリ書き込み
  - 第2バイト: ユニット種別とインデックス（上位4bit:種別、下位4bit:インデックス）
  - 第3バイト: ユニット内メモリアドレス
  - Aレジスタの値を書き込み

##### メモリアクセス命令（絶対アドレス）

- **0xB0-0xB7: LOAD_ABS** - A = Memory[第2バイト] （自身のメモリの絶対アドレス）
- **0xB8-0xBF: STORE_ABS** - Memory[第2バイト] = A （自身のメモリの絶対アドレス）

##### 間接ジャンプ命令

- **0xC0-0xC3: JMP_IND** - PC = レジスタの値（第2バイトでレジスタ指定: 0=A, 1=B, 2=C, 3=D）
- **0xC4-0xC7: JMP_ABS** - PC = 第2バイト （絶対アドレスへジャンプ）
- **0xC8-0xCF: RET** - PC = C（CALLからの復帰専用、第2,3バイトは無視）

##### 拡張演算命令

- **0xD0-0xDF: MUL_AB** - A = (A \* B) & 0xFF
- **0xE0-0xEF: LOAD_IMM** - A = 第2バイト
- **0xF0-0xFF: NOP3** - 3バイトNOP（パディング用）

### テンプレートマッチング仕様

#### 基本概念

- テンプレートはNOP0（値0）とNOP1（値1）の列で構成
- 補完パターンマッチング: 検索時は元パターンの0と1を反転したパターンを探す
- 可変長テンプレート: 最初の非NOP命令までがテンプレート
- 部分マッチング: 長いテンプレートに短いテンプレートの補完がマッチ可能

#### 補完パターンの例

```
定義側:  NOP1 NOP1 NOP0 NOP0  ; パターン: 1100
検索側:  NOP0 NOP0 NOP1 NOP1  ; 補完: 0011を探す
```

#### エネルギーコスト

- 基本実行コスト: 0.2E
- テンプレート長コスト: template_length × 0.05E
- 検索距離コスト: actual_distance × 0.01E
- 失敗時: 基本コスト + 最大検索距離 × 0.01E

#### 使用例

```
; ラベル定義（ジャンプ先）
LOOP_START:
  NOP1 NOP1 NOP0 NOP1    ; テンプレート: 1101
  MOV_AB                 ; 実際のコード開始
  ; ... ループ本体 ...

; ラベル参照（ジャンプ元）
  SEARCH_B               ; 後方検索
  NOP0 NOP0 NOP1 NOP0    ; 補完パターン: 0010を探す
  JMP_IND                ; Bレジスタ（検索結果）にジャンプ
  0x01                   ; レジスタB指定
  0x00                   ; 未使用
```

#### 自己参照の防止

補完パターンを使用するため、定義側のテンプレートが自分自身にマッチすることはない。これにより、最も近い「他の」ラベルを確実に見つけることができる。

#### 部分マッチングの動作

```
長いテンプレート:  NOP1 NOP1 NOP0 NOP0 NOP1  ; 11001
短い補完パターン:  NOP0 NOP0 NOP1              ; 001
→ 最初の3ビットの補完としてマッチ
```

### 外部ユニット操作仕様（メモリマップドI/O）

#### ユニット種別コード（上位4bit）

- 0x0: HULL
- 0x4: ASSEMBLER  
- 0x8: DISASSEMBLER
- 0xC: COMPUTER
- その他: 予約

#### ユニットメモリマップ

各ユニットは固有のメモリ領域を持ち、以下のような構成：

##### HULL（16バイト）
```
0x00-0x01: 状態（容量使用率、エネルギー保有量など）
0x02: エネルギー回収ON/OFF
0x03: マージ対象HULL ID
0x04-0x0F: 予約
```

##### ASSEMBLER（32バイト）
```
0x00-0x01: 状態（稼働中/待機中、進捗率など）
0x02-0x03: 生産中ユニット情報
0x10: 生産ユニット種別
0x11-0x1E: 生産パラメータ（種別ごとに異なる）
0x1F: 生産開始フラグ（1を書き込むと開始）
```

##### DISASSEMBLER（16バイト）
```
0x00-0x01: 状態
0x02: ターゲット指定方法（0=隣接任意、1=ユニットID指定）
0x03: ターゲットユニットID（指定時のみ）
0x04: 投入エネルギー量
0x05: 分解実行フラグ
0x06-0x0F: 予約
```

##### COMPUTER（特殊）
```
0x00-0xFF: プログラムメモリ（サイズは生成時指定）
末尾1バイト: 外部書き換え許可フラグ（0=拒否、1=許可）
```

### アドレッシングモードの使い分け

#### 相対アドレス（推奨：低コスト）

```
; ローカル変数・作業領域
STORE_A     ; 近くのメモリに保存
0x05        ; PC+5の位置
; ... 処理 ...
LOAD_A      ; 同じ相対位置から読み出し
0x05
```

#### 絶対アドレス（グローバル変数用）

```
; 共有メモリ領域（アドレス200-220を共有エリアとする）
STORE_ABS   ; 絶対アドレス200に保存
0xC8        ; 200番地
0x00        ; 第3バイト（未使用）

; 別の場所から読み出し
LOAD_ABS    ; 絶対アドレス200から読み出し
0xC8
0x00
```

#### テンプレート（位置独立コード）

```
; 重要なデータの位置をマーク
IMPORTANT_DATA:
  NOP1 NOP1 NOP0 NOP0    ; マーカー: 1100
  0x00                   ; データ本体

; 後でテンプレートで検索
SEARCH_F                 ; 前方検索
NOP0 NOP0 NOP1 NOP1    ; 補完: 0011を探す
LOAD_IND                ; 見つかった位置+1から読み出し
0x01
```

### エネルギー消費

各命令の実行には以下のエネルギーを消費：

- 1バイト命令: 0.1E
- 2バイト命令: 0.2E
- 3バイト命令: 0.3E
  - 絶対アドレス命令（LOAD_ABS, STORE_ABS, JMP_ABS）: 0.5E（高コスト）
- テンプレートマッチング:
  - 基本コスト: 0.2E
  - テンプレート長: length × 0.05E
  - 検索距離: distance × 0.01E
- ユニット操作: 1E 追加

### サブルーチン呼び出しの例

```
; メインプログラム
0x00: LOAD_IMM    ; A = 5
0x01: 0x05
0x02: CALL        ; サブルーチンを呼び出し
0x03: 0x10        ; +16バイト先（0x12）へジャンプ
0x04: NOP         ; ここに戻ってくる
; ... メインプログラムの続き

; サブルーチン（0x12から）
0x12: INC_A       ; Aをインクリメント
0x13: RET         ; Cレジスタの値（0x04）に戻る
0x14: 0x00        ; 第2バイト（無視される）
0x15: 0x00        ; 第3バイト（無視される）
```

### 複数ユニットアクセスの例

```
; 3つのASSEMBLERから空いているものを探す
  LOAD_IMM    ; D = 0（最初のASSEMBLER）
  0x00
  MOV_AD

FIND_FREE:
  ; Dレジスタの値を使ってユニット指定バイトを作成
  MOV_DA      ; D→A
  ADD_AB      ; A = A + 0x40（Bに0x40を事前設定必要）
  MOV_AB      ; 一時保存
  
  UNIT_MEM_READ ; ASSEMBLER[D]の状態確認
  ; 第2バイトはBレジスタから（0x40 + D）
  0x00        ; アドレス0x00（状態）

  JZ          ; 空いていれば使用
  0x08        ; USE_ITへ

  INC_D       ; 次のASSEMBLERへ
  LOAD_IMM    ; A = 3（ASSEMBLERの総数）
  0x03
  MOV_DA      ; D→A
  XOR_AB      ; A == 3なら0（全て確認済み）
  JZ          ; 全て使用中
  0x10        ; エラー処理へ

  JMP         ; 次を確認
  -0x10       ; FIND_FREEへ戻る

USE_IT:
  ; D番目のASSEMBLERを使用
  ; パラメータ設定と開始は上記の例と同様
```

### 子COMPUTERへのプログラム転送例

```
; 新しく生成されたCOMPUTERにプログラムを転送
; 前提：新COMPUTERのインデックスが既知（例：1番）

; まず待機ループを書き込む
  LOAD_IMM    ; A = JMP命令
  0x60
  UNIT_MEM_WRITE
  0xC1        ; COMPUTER[1]
  0x00        ; アドレス0

  LOAD_IMM    ; A = -2（自分自身へジャンプ）
  0xFE
  UNIT_MEM_WRITE
  0xC1
  0x01        ; アドレス1

; メインプログラムを書き込む（アドレス2から）
TRANSFER_LOOP:
  ; 自分のメモリから読み出し
  LOAD_IND    ; A = Memory[B]（Bはソースポインタ）
  0x00
  
  ; 子COMPUTERに書き込み
  MOV_BA      ; 一時保存
  MOV_CB      ; Cには宛先アドレス
  UNIT_MEM_WRITE
  0xC1        ; COMPUTER[1]
  ; 第3バイトはCレジスタから動的に決定される必要がある
  
  INC_B       ; ソースポインタ++
  INC_C       ; 宛先アドレス++
  ; ... 転送完了判定 ...

; 最後に待機ループを解除
  LOAD_IMM    ; A = NOP
  0x00
  UNIT_MEM_WRITE
  0xC1
  0x00        ; アドレス0の待機ループを上書き

; 書き換え許可を拒否に変更
  LOAD_IMM    ; A = 0（拒否）
  0x00
  UNIT_MEM_WRITE
  0xC1
  0xFF        ; 最終バイト（書き換え許可フラグ）
```

### 自己複製プログラムの例

```
; テンプレートマッチングを使用した自己複製プログラム
; 前提: HULLに固定されたASSEMBLERがある

; プログラム開始位置マーカー
START:
  NOP1 NOP0 NOP1 NOP0    ; テンプレート: 1010
  LOAD_IMM               ; A = プログラムサイズ
  0x40                   ; 64バイト

; 複数ASSEMBLERがある場合、最初のものを選択
  LOAD_IMM               ; D = 0（最初のASSEMBLER）
  0x00
  MOV_AD                 ; A→D

; ASSEMBLERにCOMPUTER生成を指示
  ; まず生産パラメータを設定
  LOAD_IMM               ; A = COMPUTER種別コード
  0xC0
  UNIT_MEM_WRITE         ; ASSEMBLER[0]のメモリに書き込み
  0x40                   ; 種別4、インデックス0
  0x10                   ; アドレス0x10（生産ユニット種別）
  
  LOAD_IMM               ; A = 動作周波数
  0x01                   ; 1命令/tick
  UNIT_MEM_WRITE
  0x40
  0x11                   ; アドレス0x11（パラメータ1）
  
  LOAD_IMM               ; A = メモリサイズ
  0x80                   ; 128バイト
  UNIT_MEM_WRITE
  0x40
  0x12                   ; アドレス0x12（パラメータ2）
  
  ; 生産開始
  LOAD_IMM               ; A = 1（開始フラグ）
  0x01
  UNIT_MEM_WRITE
  0x40
  0x1F                   ; アドレス0x1F（生産開始フラグ）

; 生成完了待機ループ
WAIT_LOOP:
  NOP0 NOP1 NOP0 NOP1    ; テンプレート: 0101
  UNIT_MEM_READ          ; ASSEMBLER[0]の状態確認
  0x40                   ; 種別4、インデックス0
  0x00                   ; アドレス0x00（状態）
  ; 状態の下位bitが0なら待機中
  JZ                     ; 完了なら次へ
  0x08                   ; +8バイトジャンプ（COPY_STARTへ）

  ; ループ継続（WAIT_LOOPへ戻る）
  SEARCH_B               ; 後方検索
  NOP1 NOP0 NOP1 NOP0    ; 補完パターン: 1010を探す
  JMP_IND                ; 見つかった位置へジャンプ
  0x01                   ; Bレジスタ指定
  0x00                   ; 未使用

; コピー処理開始
COPY_START:
  NOP1 NOP1 NOP0 NOP0    ; テンプレート: 1100
  LOAD_IMM               ; B = 0（コピー元アドレス）
  0x00
  LOAD_IMM               ; C = プログラムサイズ
  0x40

; メモリコピーループ
COPY_LOOP:
  NOP0 NOP1 NOP1 NOP0    ; テンプレート: 0110
  LOAD_IND               ; A = Memory[B]
  0x00                   ; オフセット0
  UNIT_CMD               ; 新COMPUTERメモリ書き込み
  0xC0                   ; COMPUTER種別
  0x02                   ; メモリ書き込みコマンド
  INC_A                  ; B++（次のアドレス）
  MOV_AB                 ; A→B
  DEC_C                  ; カウンタ減算
  JNZ                    ; まだ残りがあれば
  0x08                   ; +8バイト先へ（次の検索命令をスキップ）

  ; ループ継続（COPY_LOOPへ戻る）
  SEARCH_B               ; 後方検索
  NOP1 NOP0 NOP0 NOP1    ; 補完パターン: 1001を探す
  JMP_IND                ; 見つかった位置へジャンプ
  0x01                   ; Bレジスタ指定
  0x00                   ; 未使用

; 新COMPUTERを分離
  UNIT_CMD               ; HULLへコマンド
  0x00                   ; HULL種別
  0x03                   ; 分離コマンド
```

### COMPUTERの生成について

- COMPUTERは唯一自律動作するユニットである。生成が完了した次のtickから動作を始めるが、生成直後はプログラムカウンタ、ワーキングレジスタ、フラグ、メモリの全ての値は0である
  - その状態（NOP命令のみがメモリに入っている）でCOMPUTERが動作しても何も行わない（メモリの最後までNOP命令を実行したら、またメモリの先頭へ戻って実行）
  - 生成したCOMPUTERに意味のある仕事を行わせたい場合、先頭にループを書き込んでおき、そのループを実行している間にメモリに内容を書き込み、最後にその先頭ループを削除（NOPで上書き）する、という手順でメモリの書き込みを行うことができる

### 外部ユニットとのメモリマップドI/O

#### 基本概念
- 全てのユニットは固有のメモリ領域を持つ
- 接続されたユニットのメモリは、UNIT_MEM_READ/UNIT_MEM_WRITE命令でアクセス
- 複数引数を要する操作は、引数を全て書き込んでから実行フラグを設定

#### アクセス方式
```
; ユニット指定（第2バイト）
; 上位4bit: ユニット種別（0x0=HULL, 0x4=ASSEMBLER, 0x8=DISASSEMBLER, 0xC=COMPUTER）
; 下位4bit: 同種ユニットのインデックス（0-15）

; 例：3番目のASSEMBLER（種別0x4、インデックス3）
0x43  ; = 0x40 | 0x03
```

#### 利点
- **アトミック性**: 全パラメータ設定後に実行
- **統一性**: 全ユニットが同じインターフェース
- **拡張性**: 新ユニット追加が容易

### メモリ書き込み機構（暫定案B採用）

- COMPUTERは「外部からのメモリ書き換え許可/拒否」プロパティを持つ
- 生成時は「許可」状態で生成される
- 親COMPUTERは生成した子COMPUTERのメモリに書き込み可能（UNIT_MEM_WRITE使用）
- 書き込み完了後、子COMPUTERの書き換え許可を「拒否」に変更することを推奨

### 命令実行とメモリ破損への耐性

#### 命令境界のずれへの対応

- 可変長命令により、どの位置から読み始めても有効な命令として解釈
- 最悪でも3バイト以内に正常な命令境界に復帰

#### メモリ内容変化への対応

- 全ての8bit値が何らかの有効な命令にマッピング
- NOP0（0x00-0x03）とNOP1（0x04-0x07）により、テンプレート機能を維持しつつゼロクリアされた領域も実行可能
- 補完パターンマッチングにより、コードの位置が変わっても動作継続可能

#### 進化の可能性

- ビット反転により別の命令に変化（例: INC_A → DEC_A）
- パターンの変化により、ジャンプ先が変更
- 冗長エンコーディングにより、致命的なエラーを回避しつつ変異を許容

## TODO項目

### 解決済み項目

- ✅ ワーキングレジスタ: A, B, C, Dの4本（各8bit）
- ✅ フラグ: ゼロフラグとキャリーフラグの2種類
- ✅ メモリ: 各8bitアドレス、最大256バイト
- ✅ 命令セット: 可変長命令（1-3バイト）、完全定義済み
- ✅ テンプレートマッチング: NOP0/NOP1による補完パターン方式
- ✅ エネルギー消費: 命令種別ごとに定義済み
- ✅ メモリ書き込み機構: 暫定案B採用（外部書き換え許可/拒否プロパティ）
- ✅ アドレッシングモード: 相対・絶対・テンプレートの3方式
- ✅ 複数ユニット識別: Dレジスタによるインデックス方式

### 未解決項目

#### 1. 外部ユニット連携

- TODO: ユニット種別コードの詳細定義（現在は例示のみ）
- TODO: コマンド種別の詳細定義
- TODO: UNIT_READの読み取りパラメータ仕様
- TODO: アクション予約タイミング（即座実行 or 次tick予約）

#### 2. メモリ書き込み機構の詳細

- TODO: 外部書き換え許可状態の切り替え方法
- TODO: 複数COMPUTERからの同時書き込み競合処理
- TODO: 部分書き込み時の一貫性保証

#### 3. パフォーマンス関連

- TODO: テンプレートマッチングの最大検索距離のデフォルト値
- TODO: 動作周波数の実用的な上限値（現在はコストで制限）
