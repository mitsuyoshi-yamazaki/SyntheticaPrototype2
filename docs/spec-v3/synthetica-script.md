## 概要

Synthetica Scriptは、COMPUTERが実行するプログラムを記述するプログラミング言語の総称である。
COMPUTERが実行するのはCOMPUTERのメモリに格納されたバイト列を命令セットとして解釈したもので、本ファイルではこの命令セットと、命令セットを人間が記述するためのアセンブリ言語の仕様を策定する。
今後のバージョンでは、アセンブリ言語をラップして構造化プログラミングの仕組みを導入したC言語コンパイラと、GUIベースプログラミングを追加する予定である。どちらもアセンブリ言語を経由して命令セットへ変換される。

## アーキテクチャ仕様

COMPUTERのアーキテクチャ仕様について
COMPUTERは以下の機能を持つ

- プログラムカウンタ
  - プログラムカウンタは8bitの変数である
    - これによりメモリの最大容量が定まる（2^8 = 256）
    - メモリ容量の最大値は256に固定される
  - 次に実行する命令のメモリ番地を示す
  - プログラムカウンタを操作する命令以外では、命令を実行したらプログラムカウンタを1進める
    - メモリの最後尾にある命令を実行した後は、プログラムカウンタはメモリの先頭を指す
- ワーキングレジスタ
  - A, B, C, Dの4本（各8bit）
- フラグ
  - キャリフラグ
  - ゼロフラグ
- メモリ領域
  - 各領域は8bit（1バイト）
  - メモリ容量の最大値は 2^8 = 256バイト
- 外部バス
  - 回路的に接続しているユニットへアクセスするためのもの
  - アクセス制御：複数COMPUTERが同じユニットにアクセスする場合、そのtickで最後に更新された状態をとる
- 動作周波数
  - COMPUTERの動作周波数は分数を取りうる（例：1命令/3tick）
  - 分数周波数の処理：各tickでCOMPUTERユニットがそのtickで何回命令を実行できるかを管理
  - 例：1/3周波数のCOMPUTERは、3tickのうち2tickは命令を実行しない（エネルギー消費もない）
- 備考
  - 割り込み機能は持たない
    - ソフトウェアの自由度や創発性に対して大きな利点があることがわかれば将来追加する
  - セキュリティ・安全性：意図しない動作やメモリ内容の破損は進化の原動力となるため、積極的な対策は行わない
  - 無限ループ：無限ループに陥ったCOMPUTERは単にそのエージェントに不利に働くのみで、アプリケーションへの追加負荷はない

一般的に利用されているCPUと異なり、COMPUTERにはプログラムとデータの区別がない。
プログラムとデータを分離したプログラミングをしたい場合は、プログラム的にデータ領域の実行を禁止する。

## 設計要件と方針

### 設計要件

#### 大元の要件

- 人間がプログラミング可能（創発性の低い状態で設計ができること）かつ、
- シミュレーションが動作し始めたら創発性をもつこと
- （副次的な要件）進化の仕組みはシステムとしては提供しない（エージェントに進化の機能を持たせたいとしたら、人間がその"進化"をプログラミングする、もしくは偶然により自然発生的に進化が始まるのを待つ必要がある）：これは、進化の仕組みをシステムで提供することで、進化の手法にバイアスがかかることを防止するためである

#### 具体的な要件

- メモリ上の値を確認すれば、（他ユニットの挙動はさておき）COMPUTERの動作が一意に決定できること
- メモリ上の値、ワーキングレジスタの値、プログラムカウンタの値が欠損、破損、変更しても、実行されるSynthetica Scriptの命令として解釈できること

### 設計方針

#### 1. 可変長命令方式

- 命令長を固定せず、命令の最初のバイトで命令長を決定
- 1バイト命令（頻出・基本命令）、2バイト命令（オペランド付き）、3バイト命令（拡張命令）

#### 2. テンプレートマッチング方式

- 特定のメモリアドレスを直接指定せず、パターンでアドレスを探索
- Tierraの設計思想を参考

#### 3. 冗長エンコーディング

- 256種類のオペコードを少数の実命令にマッピング
- DNAのコドンのように、全ての値が有効な命令として解釈される

#### 4. 相対アドレッシング中心

- 絶対アドレスではなく、現在位置からの相対位置で指定
- コードの位置独立性を確保

#### 5. 最小限の命令セット

- チューリング完全性を保ちつつ最小限の命令数

## アセンブラ言語仕様

### メモリモデル

- メモリは8bitアドレス空間（256バイト）
- 循環バッファ型（アドレス255の次は0）
- メモリの各領域は8bit（1バイト）

### レジスタ構成

- PC（プログラムカウンタ）: 8bit
- ワーキングレジスタ: A, B, C, D の4本（各8bit）
- フラグレジスタ:
  - Z（ゼロフラグ）: 最後の演算結果が0の時にセット
  - C（キャリーフラグ）: 加算時の桁上がり、減算時の桁下がりでセット

### 命令フォーマット

#### 命令長の判定

第1バイトの値により命令長が決定される：

- 0x00-0x3F: 1バイト命令
- 0x40-0x7F: 2バイト命令
- 0x80-0xFF: 3バイト命令

### 命令一覧

#### 1バイト命令（0x00-0x3F）

##### データ移動命令

- **0x00-0x03: NOP0** - テンプレート用NOP（値0）
- **0x04-0x07: NOP1** - テンプレート用NOP（値1）
- **0x08-0x0F: XCHG** - レジスタAとBを交換
- **0x10-0x17: MOV_AB** - レジスタAをBにコピー
- **0x18-0x1F: MOV_BA** - レジスタBをAにコピー

##### 算術演算命令

- **0x20-0x27: INC_A** - レジスタAをインクリメント
- **0x28-0x2F: DEC_A** - レジスタAをデクリメント
- **0x30-0x37: ADD_AB** - A = A + B（キャリーフラグ更新）
- **0x38-0x3F: XOR_AB** - A = A XOR B（ゼロフラグ更新）

#### 2バイト命令（0x40-0x7F）

第2バイトはオペランドまたは相対オフセット

##### メモリアクセス命令

- **0x40-0x47: LOAD_A** - A = Memory[PC + 符号付きオフセット]
- **0x48-0x4F: STORE_A** - Memory[PC + 符号付きオフセット] = A
- **0x50-0x57: LOAD_IND** - A = Memory[B + 符号付きオフセット]
- **0x58-0x5F: STORE_IND** - Memory[B + 符号付きオフセット] = A

##### 制御命令

- **0x60-0x67: JMP** - PC = PC + 符号付きオフセット
- **0x68-0x6F: JZ** - ゼロフラグがセットならジャンプ
- **0x70-0x77: JNZ** - ゼロフラグがクリアならジャンプ
- **0x78-0x7F: CALL** - Cレジスタに戻り先を保存してジャンプ

#### 3バイト命令（0x80-0xFF）

第2,3バイトで拡張オペランドを指定

##### パターンマッチング命令

- **0x80-0x87: SEARCH_F** - 前方検索（可変長テンプレート）
  - 次バイト以降のNOP0/NOP1列をテンプレートとして使用
  - テンプレート終端: 最初の非NOP命令まで
  - 補完パターンをメモリ内で検索
  - 結果: 見つかった位置をBレジスタに格納、見つからなければB=0xFF
- **0x88-0x8F: SEARCH_B** - 後方検索（SEARCH_Fと同様）
- **0x90-0x97: SEARCH_F_MAX** - 前方検索（最大距離指定）
  - 第2バイト: 最大検索距離
  - 第3バイト以降: テンプレート（可変長）
- **0x98-0x9F: SEARCH_B_MAX** - 後方検索（SEARCH_F_MAXと同様）

##### ユニット操作命令

- **0xA0-0xAF: UNIT_READ** - 外部ユニット情報読み取り
  - 第2バイト: ユニット種別
  - 第3バイト: 読み取りパラメータ
  - 結果: Aレジスタに格納
- **0xB0-0xBF: UNIT_CMD** - 外部ユニットへコマンド送信
  - 第2バイト: ユニット種別
  - 第3バイト: コマンド種別
  - Aレジスタの値をパラメータとして使用

##### 間接ジャンプ命令

- **0xC0-0xC7: JMP_IND** - PC = レジスタの値（第2バイトでレジスタ指定: 0=A, 1=B, 2=C, 3=D）
- **0xC8-0xCF: RET** - PC = C（CALLからの復帰専用、第2,3バイトは無視）

##### 拡張演算命令

- **0xD0-0xDF: MUL_AB** - A = (A \* B) & 0xFF
- **0xE0-0xEF: LOAD_IMM** - A = 第2バイト
- **0xF0-0xFF: NOP3** - 3バイトNOP（パディング用）

### テンプレートマッチング仕様

#### 基本概念

- テンプレートはNOP0（値0）とNOP1（値1）の列で構成
- 補完パターンマッチング: 検索時は元パターンの0と1を反転したパターンを探す
- 可変長テンプレート: 最初の非NOP命令までがテンプレート
- 部分マッチング: 長いテンプレートに短いテンプレートの補完がマッチ可能

#### 補完パターンの例

```
定義側:  NOP1 NOP1 NOP0 NOP0  ; パターン: 1100
検索側:  NOP0 NOP0 NOP1 NOP1  ; 補完: 0011を探す
```

#### エネルギーコスト

- 基本実行コスト: 0.2E
- テンプレート長コスト: template_length × 0.05E
- 検索距離コスト: actual_distance × 0.01E
- 失敗時: 基本コスト + 最大検索距離 × 0.01E

#### 使用例

```
; ラベル定義（ジャンプ先）
LOOP_START:
  NOP1 NOP1 NOP0 NOP1    ; テンプレート: 1101
  MOV_AB                 ; 実際のコード開始
  ; ... ループ本体 ...

; ラベル参照（ジャンプ元）
  SEARCH_B               ; 後方検索
  NOP0 NOP0 NOP1 NOP0    ; 補完パターン: 0010を探す
  JMP_IND                ; Bレジスタ（検索結果）にジャンプ
  0x01                   ; レジスタB指定
  0x00                   ; 未使用
```

#### 自己参照の防止

補完パターンを使用するため、定義側のテンプレートが自分自身にマッチすることはない。これにより、最も近い「他の」ラベルを確実に見つけることができる。

#### 部分マッチングの動作

```
長いテンプレート:  NOP1 NOP1 NOP0 NOP0 NOP1  ; 11001
短い補完パターン:  NOP0 NOP0 NOP1              ; 001
→ 最初の3ビットの補完としてマッチ
```

### 外部ユニット操作仕様

#### ユニット種別コード（第2バイト）

- 0x00-0x3F: HULL操作
- 0x40-0x7F: ASSEMBLER操作
- 0x80-0xBF: DISASSEMBLER操作
- 0xC0-0xFF: 予約

#### 基本的なコマンド（第3バイト）

- 0x00: 状態読み取り
- 0x01: アクション予約
- 0x02: パラメータ設定
- その他: ユニット種別ごとに定義

### エネルギー消費

各命令の実行には以下のエネルギーを消費：

- 1バイト命令: 0.1E
- 2バイト命令: 0.2E
- 3バイト命令: 0.3E
- テンプレートマッチング:
  - 基本コスト: 0.2E
  - テンプレート長: length × 0.05E
  - 検索距離: distance × 0.01E
- ユニット操作: 1E 追加

### サブルーチン呼び出しの例

```
; メインプログラム
0x00: LOAD_IMM    ; A = 5
0x01: 0x05
0x02: CALL        ; サブルーチンを呼び出し
0x03: 0x10        ; +16バイト先（0x12）へジャンプ
0x04: NOP         ; ここに戻ってくる
; ... メインプログラムの続き

; サブルーチン（0x12から）
0x12: INC_A       ; Aをインクリメント
0x13: RET         ; Cレジスタの値（0x04）に戻る
0x14: 0x00        ; 第2バイト（無視される）
0x15: 0x00        ; 第3バイト（無視される）
```

### 自己複製プログラムの例

```
; テンプレートマッチングを使用した自己複製プログラム
; 前提: HULLに固定されたASSEMBLERがある

; プログラム開始位置マーカー
START:
  NOP1 NOP0 NOP1 NOP0    ; テンプレート: 1010
  LOAD_IMM               ; A = プログラムサイズ
  0x40                   ; 64バイト

; ASSEMBLERにCOMPUTER生成を指示
  UNIT_CMD               ; ASSEMBLERへコマンド
  0x40                   ; ASSEMBLER種別
  0x01                   ; 生成開始コマンド

; 生成完了待機ループ
WAIT_LOOP:
  NOP0 NOP1 NOP0 NOP1    ; テンプレート: 0101
  UNIT_READ              ; ASSEMBLER状態確認
  0x40                   ; ASSEMBLER種別
  0x00                   ; 状態読み取り
  JZ                     ; 完了なら次へ
  0x08                   ; +8バイトジャンプ（COPY_STARTへ）

  ; ループ継続（WAIT_LOOPへ戻る）
  SEARCH_B               ; 後方検索
  NOP1 NOP0 NOP1 NOP0    ; 補完パターン: 1010を探す
  JMP_IND                ; 見つかった位置へジャンプ
  0x01                   ; Bレジスタ指定
  0x00                   ; 未使用

; コピー処理開始
COPY_START:
  NOP1 NOP1 NOP0 NOP0    ; テンプレート: 1100
  LOAD_IMM               ; B = 0（コピー元アドレス）
  0x00
  LOAD_IMM               ; C = プログラムサイズ
  0x40

; メモリコピーループ
COPY_LOOP:
  NOP0 NOP1 NOP1 NOP0    ; テンプレート: 0110
  LOAD_IND               ; A = Memory[B]
  0x00                   ; オフセット0
  UNIT_CMD               ; 新COMPUTERメモリ書き込み
  0xC0                   ; COMPUTER種別
  0x02                   ; メモリ書き込みコマンド
  INC_A                  ; B++（次のアドレス）
  MOV_AB                 ; A→B
  DEC_C                  ; カウンタ減算
  JNZ                    ; まだ残りがあれば
  0x08                   ; +8バイト先へ（次の検索命令をスキップ）

  ; ループ継続（COPY_LOOPへ戻る）
  SEARCH_B               ; 後方検索
  NOP1 NOP0 NOP0 NOP1    ; 補完パターン: 1001を探す
  JMP_IND                ; 見つかった位置へジャンプ
  0x01                   ; Bレジスタ指定
  0x00                   ; 未使用

; 新COMPUTERを分離
  UNIT_CMD               ; HULLへコマンド
  0x00                   ; HULL種別
  0x03                   ; 分離コマンド
```

### COMPUTERの生成について

- COMPUTERは唯一自律動作するユニットである。生成が完了した次のtickから動作を始めるが、生成直後はプログラムカウンタ、ワーキングレジスタ、フラグ、メモリの全ての値は0である
  - その状態（NOP命令のみがメモリに入っている）でCOMPUTERが動作しても何も行わない（メモリの最後までNOP命令を実行したら、またメモリの先頭へ戻って実行）
  - 生成したCOMPUTERに意味のある仕事を行わせたい場合、先頭にループを書き込んでおき、そのループを実行している間にメモリに内容を書き込み、最後にその先頭ループを削除（NOPで上書き）する、という手順でメモリの書き込みを行うことができる

### メモリ書き込み機構（暫定案B採用）

- COMPUTERは「外部からのメモリ書き換え許可/拒否」プロパティを持つ
- 生成時は「許可」状態で生成される
- 親COMPUTERは生成した子COMPUTERのメモリに書き込み可能
- 書き込み完了後、子COMPUTERの書き換え許可を「拒否」に変更することを推奨

### 命令実行とメモリ破損への耐性

#### 命令境界のずれへの対応

- 可変長命令により、どの位置から読み始めても有効な命令として解釈
- 最悪でも3バイト以内に正常な命令境界に復帰

#### メモリ内容変化への対応

- 全ての8bit値が何らかの有効な命令にマッピング
- NOP0（0x00-0x03）とNOP1（0x04-0x07）により、テンプレート機能を維持しつつゼロクリアされた領域も実行可能
- 補完パターンマッチングにより、コードの位置が変わっても動作継続可能

#### 進化の可能性

- ビット反転により別の命令に変化（例: INC_A → DEC_A）
- パターンの変化により、ジャンプ先が変更
- 冗長エンコーディングにより、致命的なエラーを回避しつつ変異を許容

## TODO項目

### 解決済み項目

- ✅ ワーキングレジスタ: A, B, C, Dの4本（各8bit）
- ✅ フラグ: ゼロフラグとキャリーフラグの2種類
- ✅ メモリ: 各8bitアドレス、最大256バイト
- ✅ 命令セット: 可変長命令（1-3バイト）、完全定義済み
- ✅ テンプレートマッチング: NOP0/NOP1による補完パターン方式
- ✅ エネルギー消費: 命令種別ごとに定義済み
- ✅ メモリ書き込み機構: 暫定案B採用（外部書き換え許可/拒否プロパティ）

### 未解決項目

#### 1. 外部ユニット連携

- TODO: ユニット種別コードの詳細定義（現在は例示のみ）
- TODO: コマンド種別の詳細定義
- TODO: UNIT_READの読み取りパラメータ仕様
- TODO: アクション予約タイミング（即座実行 or 次tick予約）

#### 2. メモリ書き込み機構の詳細

- TODO: 外部書き換え許可状態の切り替え方法
- TODO: 複数COMPUTERからの同時書き込み競合処理
- TODO: 部分書き込み時の一貫性保証

#### 3. パフォーマンス関連

- TODO: テンプレートマッチングの最大検索距離のデフォルト値
- TODO: 動作周波数の実用的な上限値（現在はコストで制限）
